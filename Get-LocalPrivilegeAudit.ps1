<#
.SYNOPSIS
    A PowerShell tool for auditing local user privileges on a system.

.DESCRIPTION
    This tool is designed to be run as Administrator. 
    To run it without Administrator, the secedit configuration needs to be placed into the directory this tool is being run in
    This file can be generated by running the command "secedit /export /cfg secpol.cfg"
    
    This tool performs an audit of the local system's secedit database.
    It returns the user rights assignment privileges of the local system and the users that have them.

.PARAMETER Output 
    Parameter that specifies the output directory for the results of Get-LocalPrivilegeAudit tool.
    Aliased to -O
    The output file will be in the format LocalPrivilegeAudit-yyyy-MM-dd-HH-mm-ss.csv

.EXAMPLE
    Get-LocalPrivilegeAudit

    Descripton:
    Returns a formatted table containing information from the local system's secedit configuration database.

.EXAMPLE
    Get-LocalPrivilegeAudit -Output C:\

    Description:
    Outputs a csv file to the C:\ directory that contains the local system's user rights assignment privileges and associated usernames and SIDs.

.EXAMPLE
    Get-LocalPrivilegeAudit -ComputerNames [Computer1],[Computer2]

    Description:
    Returns a table containing the user rights assignment privileges for each provided computer

.NOTES
    Author: Josh Kimmel
    Date: July 2025

.LINK
    https://github.com/
    
#>

[CmdletBinding()]
param
(
    [Alias("o")]
    [string]$Output,

    [Alias("c")]
    [System.Array]$ComputerNames
)


#------------------------------------------------------------------------------#
#Validates the output parameter and converts it to a full path.
function Get-OutputPath
{
    param
    (
        [string]$outputPath = ""
    )

    if("" -ne $outputPath -and (Test-Path -Path $outputPath))
    {
        $fullOutputPath = (Get-Item $outputPath).FullName

        $time = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"

        $fullOutputPath += ("\LocalPrivilegeAudit-" + $time + ".csv")

        Write-Host ("Outputting to " + $fullOutputPath)
        return $fullOutputPath
    }
    elseif("" -ne $outputPath)
    {
        Write-Host ("Invalid output path. Outputting to screen.")
        return $null
    }
    else
    {
        return $null
    }

}


#------------------------------------------------------------------------------#
#Returns an array of all user rights assignment 
function Get-PrivilegeLines
{
    param
    (
        [System.Array]$seceditContent
    )

    $privilegeLines = @()

    foreach ($line in $seceditContent)
    {
        if($line.substring(0,2).equals("Se"))
        {
            $privilegeLines += $line
        }
    }

    return $privilegeLines

}

#------------------------------------------------------------------------------#
function Start-PrivilegeAudit
{
    param
    (
        [System.Array]$privilegeLines,
        [string]$computerName = $null
    )

    if($null -eq $computerName)
    {
        $computer = ($env:COMPUTERNAME)
    }
    else
    {
        $computer = $computerName
    }

    $table = New-Object System.Data.DataTable
    
    $column1 = New-Object System.Data.DataColumn("ComputerName", [string])
    $column2 = New-Object System.Data.DataColumn("Privilege", [string])
    $column3 = New-Object System.Data.DataColumn("Name", [string])
    $column4 = New-Object System.Data.DataColumn("SID", [string])
    $table.Columns.add($column1)
    $table.Columns.add($column2)
    $table.Columns.add($column3)
    $table.Columns.add($column4)


    foreach ($line in $privilegeLines)
    {

        $privilege = $line.substring(0, $line.IndexOf(" ="))

        $identities = $line.substring($line.IndexOf("=") + 2, `
        ($line.length - $privilege.length - 3))
        $identities = $identities.replace("*", "")

        $identitiesSplit = $identities.split(",")

        foreach($identity in $identitiesSplit)
        {

            try 
            {
                $sidObject = `
                New-Object System.Security.Principal.SecurityIdentifier($identity) `
                -ErrorAction Stop
                
                $name = `
                $sidObject.Translate([System.Security.Principal.NTAccount]).Value
                
                $sid = $identity
            }
            catch 
            {
                if($identity -match "^S-[0-9]+-[0-9]+-")
                {
                    $name = "No name found"
                    $sid = $identity
                }
                else
                {
                    $name = $identity
                    $sid = "No SID found"
                }
            }
            
            $row = $table.NewRow()
            $row.ComputerName = ($computer)
            $row.Privilege = ($privilege)
            $row.Name = ($name)
            $row.SID = ($sid)
            $table.Rows.Add($row)

        }

    }

    return $table
}

#------------------------------------------------------------------------------#
#Runs the audit on a remote computer
function Start-RemotePrivilegeAudit
{
    param
    (
        [string]$computerName
    )

    $session = New-PSSession -ComputerName $computerName -ErrorAction SilentlyContinue
    



    if($null -ne $session)
    {
        #Returns true if being run as administrator
        $isAdmin = Invoke-Command -Session $session -ScriptBlock `
        {([Security.Principal.WindowsPrincipal]`
        [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole(`
        [Security.Principal.WindowsBuiltInRole]::Administrator)}

        Invoke-Command -Session $session -ScriptBlock `
        {$currentPath = (Get-Location).ToString()}

        $computerName = Invoke-Command -Session $session -ScriptBlock `
        {($env:COMPUTERNAME)}

        #Creates a secedit export if run as admin
        if($isAdmin)
        {
            Invoke-Command -Session $session -ScriptBlock `
            {$seceditStatus = secedit /export /cfg ($currentPath + "\secpol.cfg")}

            $createdFile = $true
        }


        $seceditContent = Invoke-Command -Session $session -ScriptBlock `
        {Get-Content ($currentPath + "\secpol.cfg") `
        -ErrorAction SilentlyContinue}


        if($createdFile)
        {
            Invoke-Command -Session $session -ScriptBlock `
            {Remove-Item ($currentPath + "\secpol.cfg") -Force}
        }
        

        if($null -ne $seceditContent)
        {
            $privilegeLines = Get-PrivilegeLines -SeceditContent $seceditContent 
            $table = Start-PrivilegeAudit -PrivilegeLines $privilegeLines -ComputerName $computerName
        }
        else
        {
            Write-Host ("Could not find secpol.cfg on " + $computerName)
            Write-Host ("Try running as Administrator or placing secpol.cfg in this directory.")
        }


        Write-Output $table
        return $table

    }
    else
    {
        Write-Host ("Could not establish a session with " + $computer)
        return $null
    }

}



#------------------------------------------------------------------------------#
#Main


if($null -ne $ComputerNames)
{
    foreach ($computer in $ComputerNames)
    {
        $table += Start-RemotePrivilegeAudit -ComputerName $computer
    }
}
else
{
    #Returns true if being run as administrator
    $isAdmin = ([Security.Principal.WindowsPrincipal] `
    [Security.Principal.WindowsIdentity]::GetCurrent() `
    ).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)

    $currentPath = (Get-Location).ToString() 


    if($isAdmin)
    {
        $seceditStatus = secedit /export /cfg ($currentPath + "\secpol.cfg")
        $createdFile = $true
    }

    try 
    {
        $seceditContent = Get-Content ($currentPath + "\secpol.cfg") -ErrorAction Stop
    }
    catch 
    {
        Write-Host "Could not find secpol.cfg."
        Write-Host "Try running as Administrator or placing secpol.cfg in this directory."
        exit
    }

    $privilegeLines = Get-PrivilegeLines -SeceditContent $seceditContent
    $table += Start-PrivilegeAudit -PrivilegeLines $privilegeLines -computerName $env:COMPUTERNAME
    
}


$outputPath = Get-OutputPath -OutputPath $output

if($null -ne $outputPath)
{
    $table | Export-Csv -Path $outputPath -NoTypeInformation
}
else
{
    Write-Output $table
}


